<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>My Project: projeto/logica.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">My Project
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_7e5d7e004b344f685f59d01929914aa0.html">projeto</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">logica.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &quot;<a class="el" href="projeto_2listas_8h_source.html">listas.h</a>&quot;</code><br />
</div><div class="textblock"><div class="dynheader">
Include dependency graph for logica.h:</div>
<div class="dyncontent">
<div class="center"><img src="projeto_2logica_8h__incl.png" border="0" usemap="#projeto_2logica_8h" alt=""/></div>
<!-- MAP 0 -->
</div>
</div>
<p><a href="projeto_2logica_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a53472e75f056ceb02b5387193021838a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="projeto_2logica_8h.html#a53472e75f056ceb02b5387193021838a">jogar</a> (<a class="el" href="structESTADO.html">ESTADO</a> *estado, <a class="el" href="structCOORDENADA.html">COORDENADA</a> c)</td></tr>
<tr class="memdesc:a53472e75f056ceb02b5387193021838a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executa a jogada em si. Se algum jogador vencer a partida, após a execução de uma jogada, retorna o valor 2. Se a jogada não for válida, a função retorna 0. Caso não for nenhum dos casos anteriores, devolve 1. Atualiza a struct principal mediante a jogada efetuada.  <a href="projeto_2logica_8h.html#a53472e75f056ceb02b5387193021838a">More...</a><br /></td></tr>
<tr class="separator:a53472e75f056ceb02b5387193021838a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa3fd9c526e661b27383a69e5a5277f0"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="projeto_2logica_8h.html#aaa3fd9c526e661b27383a69e5a5277f0">verifica_fim</a> (<a class="el" href="structESTADO.html">ESTADO</a> *e, int l, int c, int j)</td></tr>
<tr class="memdesc:aaa3fd9c526e661b27383a69e5a5277f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Esta função verifica se o jogo chegou ao fim. Verifica as condições de fim de jogo,isto é, "jogador atual nas extremidades 1 ou 2, ou jogador atual
encurralado". Retorna 0 caso não se verifique nenhum, em contrapartida devolve o número do jogador vencedor.  <a href="projeto_2logica_8h.html#aaa3fd9c526e661b27383a69e5a5277f0">More...</a><br /></td></tr>
<tr class="separator:aaa3fd9c526e661b27383a69e5a5277f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3f8800d9f979e4b250c2603de7dcadd"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="projeto_2logica_8h.html#ad3f8800d9f979e4b250c2603de7dcadd">verifica_valida</a> (<a class="el" href="structESTADO.html">ESTADO</a> *e, <a class="el" href="structCOORDENADA.html">COORDENADA</a> jog_ant, <a class="el" href="structCOORDENADA.html">COORDENADA</a> jog_efet)</td></tr>
<tr class="memdesc:ad3f8800d9f979e4b250c2603de7dcadd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Esta função verifica se a jogada que se pretende efetuar é válida. Para a jogada ser válida, é necessário que a casa para onde esta se pretende efetuar esteja: 1) Vazia (sendo do tipo VAZIO, UM ou DOIS); 2) A uma distância de 1 na horizontal, vertical, ou diagonal da casa atual. Devolve 1 caso for válida, retorna 0 caso contrário.  <a href="projeto_2logica_8h.html#ad3f8800d9f979e4b250c2603de7dcadd">More...</a><br /></td></tr>
<tr class="separator:ad3f8800d9f979e4b250c2603de7dcadd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a105c7792d2784bd2c00f5e707266bc46"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structCOORDENADA.html">COORDENADA</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="projeto_2logica_8h.html#a105c7792d2784bd2c00f5e707266bc46">estrategia_paridade</a> (<a class="el" href="structESTADO.html">ESTADO</a> *e)</td></tr>
<tr class="memdesc:a105c7792d2784bd2c00f5e707266bc46"><td class="mdescLeft">&#160;</td><td class="mdescRight">Função principal da heurística da paridade. Devolve a melhor jogada possível tendo em conta tal estratégia que procura sempre a jogada que deixará uma restante par do tabuleiro.  <a href="projeto_2logica_8h.html#a105c7792d2784bd2c00f5e707266bc46">More...</a><br /></td></tr>
<tr class="separator:a105c7792d2784bd2c00f5e707266bc46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8293a66c6ce9efae086fba59bb8c884"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="projeto_2logica_8h.html#aa8293a66c6ce9efae086fba59bb8c884">calcula_area</a> (<a class="el" href="structCOORDENADA.html">COORDENADA</a> *possiveljogada, <a class="el" href="structESTADO.html">ESTADO</a> *e)</td></tr>
<tr class="memdesc:aa8293a66c6ce9efae086fba59bb8c884"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calcula a área restante (casas vazias possíveis de chegar) do tabuleiro simulada a partir de uma possível jogada.  <a href="projeto_2logica_8h.html#aa8293a66c6ce9efae086fba59bb8c884">More...</a><br /></td></tr>
<tr class="separator:aa8293a66c6ce9efae086fba59bb8c884"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62f43dfd205580f152712e9f18276103"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="projeto_2logica_8h.html#a62f43dfd205580f152712e9f18276103">transfere_tabuleiro</a> (<a class="el" href="bot_2dados_8h.html#aba91601f16d4c485b2d9b8c429f27039">CASA</a> tabuleiro_1[8][8], <a class="el" href="bot_2dados_8h.html#aba91601f16d4c485b2d9b8c429f27039">CASA</a> tabuleiro_2[8][8])</td></tr>
<tr class="memdesc:a62f43dfd205580f152712e9f18276103"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dado um tabuleiro1 e um tabuleiro2, transfere os dados do tabuleiro 2 para o tabuleiro 1.  <a href="projeto_2logica_8h.html#a62f43dfd205580f152712e9f18276103">More...</a><br /></td></tr>
<tr class="separator:a62f43dfd205580f152712e9f18276103"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adce50d8ee37c0296fcab65772db0fc57"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structCOORDENADA.html">COORDENADA</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="projeto_2logica_8h.html#adce50d8ee37c0296fcab65772db0fc57">estrategia_floodfill</a> (<a class="el" href="structESTADO.html">ESTADO</a> *e)</td></tr>
<tr class="memdesc:adce50d8ee37c0296fcab65772db0fc57"><td class="mdescLeft">&#160;</td><td class="mdescRight">Função principal da heurística floodfill. Devolve a melhor jogada possível tendo em conta tal estratégia que procura sempre a jogada que faz parte de um caminho mais curto para vitória ou mais longo para derrota.  <a href="projeto_2logica_8h.html#adce50d8ee37c0296fcab65772db0fc57">More...</a><br /></td></tr>
<tr class="separator:adce50d8ee37c0296fcab65772db0fc57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab50719b4d8ccd4926730de9ab6b1bf26"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structCOORDENADA.html">COORDENADA</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="projeto_2logica_8h.html#ab50719b4d8ccd4926730de9ab6b1bf26">insere_possiveis_jogadas</a> (<a class="el" href="structESTADO.html">ESTADO</a> *e, <a class="el" href="bot_2listas_8h.html#ac294034fbe3bf9846e0465051a477f55">LISTA</a> *posicoesvazias, <a class="el" href="structCOORDENADA.html">COORDENADA</a> coord_escolhida)</td></tr>
<tr class="memdesc:ab50719b4d8ccd4926730de9ab6b1bf26"><td class="mdescLeft">&#160;</td><td class="mdescRight">Preenche a lista (*posicoesvazias) com as possíveis jogadas que o jogador atual consegue efetuar. Retorna uma coordenada que vai servir mais a frente para ver se é preciso efetuar uma estratégia ou não. Caso a coordenada devolvida seja a mesma que a função recebeu como argumento (3,4), significa que ela não foi alterada em momento algum durante a função e por tanto não foi encontrado uma jogada que garanta vitória ao jogador atual(pois assim a coordenada a devolver seria a de tal jogada).  <a href="projeto_2logica_8h.html#ab50719b4d8ccd4926730de9ab6b1bf26">More...</a><br /></td></tr>
<tr class="separator:ab50719b4d8ccd4926730de9ab6b1bf26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b7227ac52e72c662be8e60fcab31f81"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="projeto_2logica_8h.html#a4b7227ac52e72c662be8e60fcab31f81">inicializa_num_casa</a> (int num_casa[8][8], <a class="el" href="structESTADO.html">ESTADO</a> *e, int flag)</td></tr>
<tr class="memdesc:a4b7227ac52e72c662be8e60fcab31f81"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inicializa a matriz que vai conter o valor de cada casa do tabuleiro para o algoritimo floodfill. Tal inicialização dependerá da flag dada. Isto porque podemos fazer tal inicialização em 2 momentos distintos: quando é possível chegar na cada da vitória e quando não é. Mediante os 2 casos teremos uma inicialização diferente.  <a href="projeto_2logica_8h.html#a4b7227ac52e72c662be8e60fcab31f81">More...</a><br /></td></tr>
<tr class="separator:a4b7227ac52e72c662be8e60fcab31f81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a827c627b01e9d538ab33ec1be379cdfc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structCOORDENADA.html">COORDENADA</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="projeto_2logica_8h.html#a827c627b01e9d538ab33ec1be379cdfc">auxiliar_floodfill</a> (<a class="el" href="structESTADO.html">ESTADO</a> *e, <a class="el" href="bot_2listas_8h.html#ac294034fbe3bf9846e0465051a477f55">LISTA</a> possiveis_jogadas, <a class="el" href="structCOORDENADA.html">COORDENADA</a> coord_escolhida)</td></tr>
<tr class="memdesc:a827c627b01e9d538ab33ec1be379cdfc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Função invocada pela funcção "estratégia_floodfill" para melhor organização e gestão de memória da mesma. Realiza o processo da escolha da melhor jogada a ser efetuada (que é devolvida pela função). É a função cerne do raciocínio em si por trás de tal estratégia.  <a href="projeto_2logica_8h.html#a827c627b01e9d538ab33ec1be379cdfc">More...</a><br /></td></tr>
<tr class="separator:a827c627b01e9d538ab33ec1be379cdfc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac62ec1b8cfc401f9972b69d144fc5809"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="projeto_2logica_8h.html#ac62ec1b8cfc401f9972b69d144fc5809">preenche_valor_das_casas</a> (int num_casa[8][8], <a class="el" href="structESTADO.html">ESTADO</a> *e, int flag)</td></tr>
<tr class="memdesc:ac62ec1b8cfc401f9972b69d144fc5809"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dá para cada casa do tabuleiro um valor específico. Tal valor será importante para indicar o caminho mais curto para a casa da vitória(ou o mais longo para a casa da derrota mediante a flag dada como argumento). As casas não preenchidas aqui já foram preenchidas pela função que inicializa a matriz com os valores de cada casa do tabuleiro. É parado o preenchimento quando consigo chegar na casa onde estou partindo de um preenchimento com origem na casa que desejo chegar, e isto simboliza que encontrei o caimho mais curto para ela. Tal função devolve o valor que dei a casa onde estou subtraído por 1, sendo tal valor único, sevindo de guia para conseguir retirar a jogada desejada (pois ela terá tal valor devolvido).  <a href="projeto_2logica_8h.html#ac62ec1b8cfc401f9972b69d144fc5809">More...</a><br /></td></tr>
<tr class="separator:ac62ec1b8cfc401f9972b69d144fc5809"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fc83e127140c4d6149cb87cb7152917"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structCOORDENADA.html">COORDENADA</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="projeto_2logica_8h.html#a3fc83e127140c4d6149cb87cb7152917">duplica_coordenada</a> (<a class="el" href="structCOORDENADA.html">COORDENADA</a> coordenada)</td></tr>
<tr class="memdesc:a3fc83e127140c4d6149cb87cb7152917"><td class="mdescLeft">&#160;</td><td class="mdescRight">Duplica uma coordenada e coloca ela num endereço novo. Possui utilidade no preenchimento da lista ligada de modo a evitar perder seu conteúdo mais tarde.  <a href="projeto_2logica_8h.html#a3fc83e127140c4d6149cb87cb7152917">More...</a><br /></td></tr>
<tr class="separator:a3fc83e127140c4d6149cb87cb7152917"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a121fc1e4e0bc77a026906d18f984d7ea"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structCOORDENADA.html">COORDENADA</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="projeto_2logica_8h.html#a121fc1e4e0bc77a026906d18f984d7ea">devolve_coordenada_flood</a> (int valor_casa_atual, <a class="el" href="bot_2listas_8h.html#ac294034fbe3bf9846e0465051a477f55">LISTA</a> possiveis_jogadas, int num_casa[8][8])</td></tr>
<tr class="memdesc:a121fc1e4e0bc77a026906d18f984d7ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Recebe o valor dado a casa tual de acordo com a estratégia floodfill, e devolve uma das casas vizinhas armazenadas na lista ligada intitulada como "possiveis_jogadas" que tenha o valor da casa atual subtraido por 1.  <a href="projeto_2logica_8h.html#a121fc1e4e0bc77a026906d18f984d7ea">More...</a><br /></td></tr>
<tr class="separator:a121fc1e4e0bc77a026906d18f984d7ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3d83ee5bb070d6530437278b415b636"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="projeto_2logica_8h.html#ab3d83ee5bb070d6530437278b415b636">verifica_adjacencia</a> (<a class="el" href="structCOORDENADA.html">COORDENADA</a> coord, int num_casa[8][8], int valor)</td></tr>
<tr class="memdesc:ab3d83ee5bb070d6530437278b415b636"><td class="mdescLeft">&#160;</td><td class="mdescRight">Temos a coordenada "coord". Queremos saber se a CASA no tabuleiro correspondente a essa coordenada "coord" está ao lado de alguma com valor (valor-1.) Para isso corremos todas as posições do tabuleiro até encontrarmos alguma ao lado da coordenada que temos ou chegarmos ao fim do tabuleiro.  <a href="projeto_2logica_8h.html#ab3d83ee5bb070d6530437278b415b636">More...</a><br /></td></tr>
<tr class="separator:ab3d83ee5bb070d6530437278b415b636"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6eceb14c20dfd2dc46fe7500803bd534"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="projeto_2logica_8h.html#a6eceb14c20dfd2dc46fe7500803bd534">verifica_quadrante</a> (<a class="el" href="structESTADO.html">ESTADO</a> *e, <a class="el" href="structCOORDENADA.html">COORDENADA</a> coord)</td></tr>
<tr class="memdesc:a6eceb14c20dfd2dc46fe7500803bd534"><td class="mdescLeft">&#160;</td><td class="mdescRight">Verifica se a coordenada "coord" faz parte de uma das casas que, se for escolhida como casa jogada pelo jogador atual, na próxima jogada ele perderá a partida pois tal casa pertencia as casas que estão ao redor de sua casa da derrota. Por tanto tal função devolve 1 se a coord estiver no quadrante seguro, isto é, sem ser ao redor da casa da derrota, e devolve 0 caso contrário.  <a href="projeto_2logica_8h.html#a6eceb14c20dfd2dc46fe7500803bd534">More...</a><br /></td></tr>
<tr class="separator:a6eceb14c20dfd2dc46fe7500803bd534"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7ade6abbed3330a0561ce9e7efcfc11"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structCOORDENADA.html">COORDENADA</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="projeto_2logica_8h.html#aa7ade6abbed3330a0561ce9e7efcfc11">floodfill_inversa</a> (int num_casa[8][8], <a class="el" href="bot_2listas_8h.html#ac294034fbe3bf9846e0465051a477f55">LISTA</a> possiveis_jogadas, <a class="el" href="structESTADO.html">ESTADO</a> *e)</td></tr>
<tr class="memdesc:aa7ade6abbed3330a0561ce9e7efcfc11"><td class="mdescLeft">&#160;</td><td class="mdescRight">Realiza a estratégia floodfill inversamente, procurando o caminho mais longo para derrota. Devolve a melhor jogada a se fazer.  <a href="projeto_2logica_8h.html#aa7ade6abbed3330a0561ce9e7efcfc11">More...</a><br /></td></tr>
<tr class="separator:aa7ade6abbed3330a0561ce9e7efcfc11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18183af7ccb1fd6405a5f39b1f56ef96"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="projeto_2logica_8h.html#a18183af7ccb1fd6405a5f39b1f56ef96">verifica_casa_vazia</a> (<a class="el" href="structESTADO.html">ESTADO</a> *e, <a class="el" href="structCOORDENADA.html">COORDENADA</a> coordenada)</td></tr>
<tr class="memdesc:a18183af7ccb1fd6405a5f39b1f56ef96"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dada uma coordenada, verifica se a casa correspondente no tabuleiro está vazia ou não. Devolve 1 caso estiver vazia,0 caso o contrário.  <a href="projeto_2logica_8h.html#a18183af7ccb1fd6405a5f39b1f56ef96">More...</a><br /></td></tr>
<tr class="separator:a18183af7ccb1fd6405a5f39b1f56ef96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99bdf7c3a8419ede03a430e02a07f815"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="projeto_2logica_8h.html#a99bdf7c3a8419ede03a430e02a07f815">auxiliarparidade</a> (<a class="el" href="structESTADO.html">ESTADO</a> *e, <a class="el" href="bot_2listas_8h.html#ac294034fbe3bf9846e0465051a477f55">LISTA</a> possiveis_jogadas, int paridade[8], <a class="el" href="structCOORDENADA.html">COORDENADA</a> *cabeca)</td></tr>
<tr class="memdesc:a99bdf7c3a8419ede03a430e02a07f815"><td class="mdescLeft">&#160;</td><td class="mdescRight">Função auxiliar da "estrategia_paridade" que preenche o array paridade(que armazena a área restante para cada possível jogada) com as respetivas áreas de cada possível jogada.  <a href="projeto_2logica_8h.html#a99bdf7c3a8419ede03a430e02a07f815">More...</a><br /></td></tr>
<tr class="separator:a99bdf7c3a8419ede03a430e02a07f815"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a95c65b2b2fbb3a1b567b5aed560287"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="projeto_2logica_8h.html#a8a95c65b2b2fbb3a1b567b5aed560287">devolve_indice_paridade</a> (int paridade[8], int flag)</td></tr>
<tr class="memdesc:a8a95c65b2b2fbb3a1b567b5aed560287"><td class="mdescLeft">&#160;</td><td class="mdescRight">Devolve o Índice do array paridade que possui a melhor "jogada" (sendo escolhido a partir de um estudo sobre as áreas do array. A prioridade são as menores áreas pares. Caso não haver áreas pares, a prioridade passa a ser as maiores áreas ímpares). A flag dada como argumento tem função importante no que respeita "avisar" quando a função está a ser ativada para o jogador 2 ou 1. Isto é, a única diferença é a prioridade que é dada ao termos 2 áreas com o mesmo valor. No caso de ser o jogador 1 a prioridade é manter a primeira como escolhida, dado que vai corresponder a uma posição ,na lista ligada de possíveis jogadas, mais perto da sua casa destino. Caso for o jogador 2 o atual é feito o contrário.  <a href="projeto_2logica_8h.html#a8a95c65b2b2fbb3a1b567b5aed560287">More...</a><br /></td></tr>
<tr class="separator:a8a95c65b2b2fbb3a1b567b5aed560287"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47d04407ac67a91a6572ff5011640928"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="projeto_2logica_8h.html#a47d04407ac67a91a6572ff5011640928">verifica_limite_tabuleiro</a> (<a class="el" href="structCOORDENADA.html">COORDENADA</a> coordenada)</td></tr>
<tr class="memdesc:a47d04407ac67a91a6572ff5011640928"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dada uma coordenada, verifica se esta é uma coordenada válida de ser jogada , isto é, esta dentro dos limites de memória do tabuleiro.  <a href="projeto_2logica_8h.html#a47d04407ac67a91a6572ff5011640928">More...</a><br /></td></tr>
<tr class="separator:a47d04407ac67a91a6572ff5011640928"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b7af3834ab9d82aa443aa046de1ca60"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structCOORDENADA.html">COORDENADA</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="projeto_2logica_8h.html#a6b7af3834ab9d82aa443aa046de1ca60">escolhe_aleatorio</a> (<a class="el" href="bot_2listas_8h.html#ac294034fbe3bf9846e0465051a477f55">LISTA</a> <a class="el" href="structlista.html">lista</a>)</td></tr>
<tr class="memdesc:a6b7af3834ab9d82aa443aa046de1ca60"><td class="mdescLeft">&#160;</td><td class="mdescRight">devolve um elemento (coordenada) aleatório de uma lista ligada  <a href="projeto_2logica_8h.html#a6b7af3834ab9d82aa443aa046de1ca60">More...</a><br /></td></tr>
<tr class="separator:a6b7af3834ab9d82aa443aa046de1ca60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a859b6fa3715b706976d64748916a4253"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="projeto_2logica_8h.html#a859b6fa3715b706976d64748916a4253">jogadaaefetuar</a> (int paridade[8])</td></tr>
<tr class="memdesc:a859b6fa3715b706976d64748916a4253"><td class="mdescLeft">&#160;</td><td class="mdescRight">devolve o índice do array paridade escolhido como índice representativo da melhor jogada sob a estratégia floodfilll  <a href="projeto_2logica_8h.html#a859b6fa3715b706976d64748916a4253">More...</a><br /></td></tr>
<tr class="separator:a859b6fa3715b706976d64748916a4253"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a id="a827c627b01e9d538ab33ec1be379cdfc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a827c627b01e9d538ab33ec1be379cdfc">&#9670;&nbsp;</a></span>auxiliar_floodfill()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structCOORDENADA.html">COORDENADA</a> auxiliar_floodfill </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structESTADO.html">ESTADO</a> *&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="bot_2listas_8h.html#ac294034fbe3bf9846e0465051a477f55">LISTA</a>&#160;</td>
          <td class="paramname"><em>possiveis_jogadas</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structCOORDENADA.html">COORDENADA</a>&#160;</td>
          <td class="paramname"><em>coord_escolhida</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Função invocada pela funcção "estratégia_floodfill" para melhor organização e gestão de memória da mesma. Realiza o processo da escolha da melhor jogada a ser efetuada (que é devolvida pela função). É a função cerne do raciocínio em si por trás de tal estratégia. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">e</td><td>apontador para o estado </td></tr>
    <tr><td class="paramname">possiveis_jogadas</td><td>lista ligada com as possíveis jogadas a efetuar pelo jogador atual </td></tr>
    <tr><td class="paramname">coord_escolhida</td><td>melhor coordenada a ser jogada, modificada e devolvida pela função. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a99bdf7c3a8419ede03a430e02a07f815"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99bdf7c3a8419ede03a430e02a07f815">&#9670;&nbsp;</a></span>auxiliarparidade()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void auxiliarparidade </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structESTADO.html">ESTADO</a> *&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="bot_2listas_8h.html#ac294034fbe3bf9846e0465051a477f55">LISTA</a>&#160;</td>
          <td class="paramname"><em>possiveis_jogadas</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>paridade</em>[8], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structCOORDENADA.html">COORDENADA</a> *&#160;</td>
          <td class="paramname"><em>cabeca</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Função auxiliar da "estrategia_paridade" que preenche o array paridade(que armazena a área restante para cada possível jogada) com as respetivas áreas de cada possível jogada. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">e</td><td>apontador para o estado do jogo </td></tr>
    <tr><td class="paramname">possiveis_jogadas</td><td>lista ligada com as possveis_jogadas </td></tr>
    <tr><td class="paramname">paridade</td><td>array que armazena a área restante para cada possível jogada </td></tr>
    <tr><td class="paramname">cabeca</td><td>apontador para coordenada que serve para retirar valores da lista ligada </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa8293a66c6ce9efae086fba59bb8c884"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8293a66c6ce9efae086fba59bb8c884">&#9670;&nbsp;</a></span>calcula_area()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int calcula_area </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCOORDENADA.html">COORDENADA</a> *&#160;</td>
          <td class="paramname"><em>possiveljogada</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structESTADO.html">ESTADO</a> *&#160;</td>
          <td class="paramname"><em>e</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calcula a área restante (casas vazias possíveis de chegar) do tabuleiro simulada a partir de uma possível jogada. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">possiveljogada</td><td>apontador para coordenada que será o ponto de partida do calculo da área restante </td></tr>
    <tr><td class="paramname">e</td><td>apontador para o estado do jogo </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a121fc1e4e0bc77a026906d18f984d7ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a121fc1e4e0bc77a026906d18f984d7ea">&#9670;&nbsp;</a></span>devolve_coordenada_flood()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structCOORDENADA.html">COORDENADA</a> devolve_coordenada_flood </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>valor_casa_atual</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="bot_2listas_8h.html#ac294034fbe3bf9846e0465051a477f55">LISTA</a>&#160;</td>
          <td class="paramname"><em>possiveis_jogadas</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>num_casa</em>[8][8]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Recebe o valor dado a casa tual de acordo com a estratégia floodfill, e devolve uma das casas vizinhas armazenadas na lista ligada intitulada como "possiveis_jogadas" que tenha o valor da casa atual subtraido por 1. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">valor_casa_atual</td><td>número dado a casa atual do jogador a partir da estratégia floodfill </td></tr>
    <tr><td class="paramname">possiveis_jogadas</td><td>lista ligada que armazenará as possíveis jogadas a se fazer </td></tr>
    <tr><td class="paramname">num_casa</td><td>matriz com os valores numéricos dados a cada possível casa do tabuleiro a partir da estratégia floodfill </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8a95c65b2b2fbb3a1b567b5aed560287"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a95c65b2b2fbb3a1b567b5aed560287">&#9670;&nbsp;</a></span>devolve_indice_paridade()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int devolve_indice_paridade </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>paridade</em>[8], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Devolve o Índice do array paridade que possui a melhor "jogada" (sendo escolhido a partir de um estudo sobre as áreas do array. A prioridade são as menores áreas pares. Caso não haver áreas pares, a prioridade passa a ser as maiores áreas ímpares). A flag dada como argumento tem função importante no que respeita "avisar" quando a função está a ser ativada para o jogador 2 ou 1. Isto é, a única diferença é a prioridade que é dada ao termos 2 áreas com o mesmo valor. No caso de ser o jogador 1 a prioridade é manter a primeira como escolhida, dado que vai corresponder a uma posição ,na lista ligada de possíveis jogadas, mais perto da sua casa destino. Caso for o jogador 2 o atual é feito o contrário. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">paridade</td><td>array que armazena a área restante para cada possível jogada </td></tr>
    <tr><td class="paramname">flag</td><td>Indicador do jogador atual </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3fc83e127140c4d6149cb87cb7152917"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3fc83e127140c4d6149cb87cb7152917">&#9670;&nbsp;</a></span>duplica_coordenada()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structCOORDENADA.html">COORDENADA</a>* duplica_coordenada </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCOORDENADA.html">COORDENADA</a>&#160;</td>
          <td class="paramname"><em>coordenada</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Duplica uma coordenada e coloca ela num endereço novo. Possui utilidade no preenchimento da lista ligada de modo a evitar perder seu conteúdo mais tarde. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">coordenada</td><td>Coordenada a ser duplicada e colocada num endereço novo </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6b7af3834ab9d82aa443aa046de1ca60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b7af3834ab9d82aa443aa046de1ca60">&#9670;&nbsp;</a></span>escolhe_aleatorio()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structCOORDENADA.html">COORDENADA</a> escolhe_aleatorio </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="bot_2listas_8h.html#ac294034fbe3bf9846e0465051a477f55">LISTA</a>&#160;</td>
          <td class="paramname"><em>lista</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>devolve um elemento (coordenada) aleatório de uma lista ligada </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lista</td><td>Lista ligada com possíveis jogadas a se efetuar </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="adce50d8ee37c0296fcab65772db0fc57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adce50d8ee37c0296fcab65772db0fc57">&#9670;&nbsp;</a></span>estrategia_floodfill()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structCOORDENADA.html">COORDENADA</a> estrategia_floodfill </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structESTADO.html">ESTADO</a> *&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Função principal da heurística floodfill. Devolve a melhor jogada possível tendo em conta tal estratégia que procura sempre a jogada que faz parte de um caminho mais curto para vitória ou mais longo para derrota. </p>
<p>Função principal da estratégia floodfill. Devolve a melhor jogada a ser efetuada pelo jogador atual. Para melhor organização tal função se ramifica numa função auxiliar que seleciona tal jogada. Caso for possível vencer a partida com base numa jogada tal funçãop auxiliar não é chamada e é devolvido o valor da coordenada da vitória.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">e</td><td>Apontador para o estado</td></tr>
    <tr><td class="paramname">e</td><td>apontador para o estado</td></tr>
  </table>
  </dd>
</dl>
<p>Função principal da heurística floodfill. Devolve a melhor jogada possível tendo em conta tal estratégia que procura sempre a jogada que faz parte de um caminho mais curto para vitória ou mais longo para derrota.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">e</td><td>apontador para o estado</td></tr>
  </table>
  </dd>
</dl>
<p>Função principal da estratégia floodfill. Devolve a melhor jogada a ser efetuada pelo jogador atual. Para melhor organização tal função se ramifica numa função auxiliar que seleciona tal jogada. Caso for possível vencer a partida com base numa jogada tal funçãop auxiliar não é chamada e é devolvido o valor da coordenada da vitória.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">e</td><td>Apontador para o estado</td></tr>
    <tr><td class="paramname">e</td><td>apontador para o estado</td></tr>
  </table>
  </dd>
</dl>
<p>Função principal da heurística floodfill. Devolve a melhor jogada possível tendo em conta tal estratégia que procura sempre a jogada que faz parte de um caminho mais curto para vitória ou mais longo para derrota.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">e</td><td>apontador para o estado </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a105c7792d2784bd2c00f5e707266bc46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a105c7792d2784bd2c00f5e707266bc46">&#9670;&nbsp;</a></span>estrategia_paridade()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structCOORDENADA.html">COORDENADA</a> estrategia_paridade </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structESTADO.html">ESTADO</a> *&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Função principal da heurística da paridade. Devolve a melhor jogada possível tendo em conta tal estratégia que procura sempre a jogada que deixará uma restante par do tabuleiro. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">e</td><td>Apontador para o estado </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa7ade6abbed3330a0561ce9e7efcfc11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7ade6abbed3330a0561ce9e7efcfc11">&#9670;&nbsp;</a></span>floodfill_inversa()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structCOORDENADA.html">COORDENADA</a> floodfill_inversa </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>num_casa</em>[8][8], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="bot_2listas_8h.html#ac294034fbe3bf9846e0465051a477f55">LISTA</a>&#160;</td>
          <td class="paramname"><em>possiveis_jogadas</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structESTADO.html">ESTADO</a> *&#160;</td>
          <td class="paramname"><em>e</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Realiza a estratégia floodfill inversamente, procurando o caminho mais longo para derrota. Devolve a melhor jogada a se fazer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">num_casa</td><td>matriz com os valores numéricos dados a cada possível casa do tabuleiro </td></tr>
    <tr><td class="paramname">possiveis_jogadas</td><td>lista ligada com as possveis_jogadas </td></tr>
    <tr><td class="paramname">e</td><td>apontador para o estado do jogo </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4b7227ac52e72c662be8e60fcab31f81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b7227ac52e72c662be8e60fcab31f81">&#9670;&nbsp;</a></span>inicializa_num_casa()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void inicializa_num_casa </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>num_casa</em>[8][8], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structESTADO.html">ESTADO</a> *&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inicializa a matriz que vai conter o valor de cada casa do tabuleiro para o algoritimo floodfill. Tal inicialização dependerá da flag dada. Isto porque podemos fazer tal inicialização em 2 momentos distintos: quando é possível chegar na cada da vitória e quando não é. Mediante os 2 casos teremos uma inicialização diferente. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">num_casa</td><td>Matriz com os valores de cada casa do tabuleiro </td></tr>
    <tr><td class="paramname">e</td><td>Apontador para o estado </td></tr>
    <tr><td class="paramname">flag</td><td>variável de aviso para diferenciar os 2 momentos distintos já enunciados </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab50719b4d8ccd4926730de9ab6b1bf26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab50719b4d8ccd4926730de9ab6b1bf26">&#9670;&nbsp;</a></span>insere_possiveis_jogadas()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structCOORDENADA.html">COORDENADA</a> insere_possiveis_jogadas </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structESTADO.html">ESTADO</a> *&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="bot_2listas_8h.html#ac294034fbe3bf9846e0465051a477f55">LISTA</a> *&#160;</td>
          <td class="paramname"><em>posicoesvazias</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structCOORDENADA.html">COORDENADA</a>&#160;</td>
          <td class="paramname"><em>coord_escolhida</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Preenche a lista (*posicoesvazias) com as possíveis jogadas que o jogador atual consegue efetuar. Retorna uma coordenada que vai servir mais a frente para ver se é preciso efetuar uma estratégia ou não. Caso a coordenada devolvida seja a mesma que a função recebeu como argumento (3,4), significa que ela não foi alterada em momento algum durante a função e por tanto não foi encontrado uma jogada que garanta vitória ao jogador atual(pois assim a coordenada a devolver seria a de tal jogada). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">e</td><td>Apontador para o estado </td></tr>
    <tr><td class="paramname">e</td><td>Apontador para o estado </td></tr>
    <tr><td class="paramname">posicoesvazias</td><td>apontador para uma lista(lista das possíveis jogadas) </td></tr>
    <tr><td class="paramname">coord_escolhida</td><td>coordenada a ser devolvida pela função </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a859b6fa3715b706976d64748916a4253"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a859b6fa3715b706976d64748916a4253">&#9670;&nbsp;</a></span>jogadaaefetuar()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int jogadaaefetuar </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>paridade</em>[8]</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>devolve o índice do array paridade escolhido como índice representativo da melhor jogada sob a estratégia floodfilll </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">paridade</td><td>array com as áreas restantes possíveis para cada jogada que se pode efetuar </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a53472e75f056ceb02b5387193021838a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53472e75f056ceb02b5387193021838a">&#9670;&nbsp;</a></span>jogar()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int jogar </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structESTADO.html">ESTADO</a> *&#160;</td>
          <td class="paramname"><em>estado</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structCOORDENADA.html">COORDENADA</a>&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Executa a jogada em si. Se algum jogador vencer a partida, após a execução de uma jogada, retorna o valor 2. Se a jogada não for válida, a função retorna 0. Caso não for nenhum dos casos anteriores, devolve 1. Atualiza a struct principal mediante a jogada efetuada. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">estado</td><td>Apontador para o estado </td></tr>
    <tr><td class="paramname">c</td><td>Coordenada da jogada efetuada </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac62ec1b8cfc401f9972b69d144fc5809"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac62ec1b8cfc401f9972b69d144fc5809">&#9670;&nbsp;</a></span>preenche_valor_das_casas()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int preenche_valor_das_casas </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>num_casa</em>[8][8], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structESTADO.html">ESTADO</a> *&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Dá para cada casa do tabuleiro um valor específico. Tal valor será importante para indicar o caminho mais curto para a casa da vitória(ou o mais longo para a casa da derrota mediante a flag dada como argumento). As casas não preenchidas aqui já foram preenchidas pela função que inicializa a matriz com os valores de cada casa do tabuleiro. É parado o preenchimento quando consigo chegar na casa onde estou partindo de um preenchimento com origem na casa que desejo chegar, e isto simboliza que encontrei o caimho mais curto para ela. Tal função devolve o valor que dei a casa onde estou subtraído por 1, sendo tal valor único, sevindo de guia para conseguir retirar a jogada desejada (pois ela terá tal valor devolvido). </p>
<p>Preenche o valor de cada casa do tabuleiro de acordo com a estratégia floodfill. Começa por preencher as casas ao redor da casa destino com o valor da (casa destino + 1). Tal processo se aplica iterativamente sempre preenchendo casas adijacentes a uma casa com valor n, com o valor n + 1. Tal processo se verifica até conseguir chegar na minha casa atual, o que significa que existe um caminho para o destino, ou caso contrário saberei que não existe. A função devolve -1 quando não existe caminho mais curto para vitória e devolve um valor diferente de 1, que será correspondente ao valor n dado a minha casa atual(sendo ele o parãmetro utilizado posteriormente para retirar a melhor jogada que será a vizinha com valor n - 1).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">num_casa</td><td>matriz com os valores de casa casa do tabuleiro </td></tr>
    <tr><td class="paramname">e</td><td>apontador para o estado </td></tr>
    <tr><td class="paramname">flag</td><td>Indicador se devo preencher supondo que quero encontrar o caminho mais curto para minha casa ou o mais longo para a casa da derrota</td></tr>
    <tr><td class="paramname">num_casa</td><td>matriz com os valores numéricos(de cada casa do tabuleiro) inicializados a -1 que seráo agora preenchidos pela função </td></tr>
    <tr><td class="paramname">e</td><td>apontador para o estado do jogo </td></tr>
    <tr><td class="paramname">flag</td><td>indica se estou usando a função para encontrar o caminho mais curto para vitória ou o mais longo para derrota</td></tr>
  </table>
  </dd>
</dl>
<p>Dá para cada casa do tabuleiro um valor específico. Tal valor será importante para indicar o caminho mais curto para a casa da vitória(ou o mais longo para a casa da derrota mediante a flag dada como argumento). As casas não preenchidas aqui já foram preenchidas pela função que inicializa a matriz com os valores de cada casa do tabuleiro. É parado o preenchimento quando consigo chegar na casa onde estou partindo de um preenchimento com origem na casa que desejo chegar, e isto simboliza que encontrei o caimho mais curto para ela. Tal função devolve o valor que dei a casa onde estou subtraído por 1, sendo tal valor único, sevindo de guia para conseguir retirar a jogada desejada (pois ela terá tal valor devolvido).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">num_casa</td><td>matriz com os valores numéricos(de cada casa do tabuleiro) inicializados a -1 que seráo agora preenchidos pela função </td></tr>
    <tr><td class="paramname">e</td><td>apontador para o estado do jogo </td></tr>
    <tr><td class="paramname">flag</td><td>indica se estou usando a função para encontrar o caminho mais curto para vitória ou o mais longo para derrota</td></tr>
  </table>
  </dd>
</dl>
<p>Preenche o valor de cada casa do tabuleiro de acordo com a estratégia floodfill. Começa por preencher as casas ao redor da casa destino com o valor da (casa destino + 1). Tal processo se aplica iterativamente sempre preenchendo casas adijacentes a uma casa com valor n, com o valor n + 1. Tal processo se verifica até conseguir chegar na minha casa atual, o que significa que existe um caminho para o destino, ou caso contrário saberei que não existe. A função devolve -1 quando não existe caminho mais curto para vitória e devolve um valor diferente de 1, que será correspondente ao valor n dado a minha casa atual(sendo ele o parãmetro utilizado posteriormente para retirar a melhor jogada que será a vizinha com valor n - 1).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">num_casa</td><td>matriz com os valores de casa casa do tabuleiro </td></tr>
    <tr><td class="paramname">e</td><td>apontador para o estado </td></tr>
    <tr><td class="paramname">flag</td><td>Indicador se devo preencher supondo que quero encontrar o caminho mais curto para minha casa ou o mais longo para a casa da derrota</td></tr>
    <tr><td class="paramname">num_casa</td><td>matriz com os valores numéricos(de cada casa do tabuleiro) inicializados a -1 que seráo agora preenchidos pela função </td></tr>
    <tr><td class="paramname">e</td><td>apontador para o estado do jogo </td></tr>
    <tr><td class="paramname">flag</td><td>indica se estou usando a função para encontrar o caminho mais curto para vitória ou o mais longo para derrota</td></tr>
  </table>
  </dd>
</dl>
<p>Dá para cada casa do tabuleiro um valor específico. Tal valor será importante para indicar o caminho mais curto para a casa da vitória(ou o mais longo para a casa da derrota mediante a flag dada como argumento). As casas não preenchidas aqui já foram preenchidas pela função que inicializa a matriz com os valores de cada casa do tabuleiro. É parado o preenchimento quando consigo chegar na casa onde estou partindo de um preenchimento com origem na casa que desejo chegar, e isto simboliza que encontrei o caimho mais curto para ela. Tal função devolve o valor que dei a casa onde estou subtraído por 1, sendo tal valor único, sevindo de guia para conseguir retirar a jogada desejada (pois ela terá tal valor devolvido).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">num_casa</td><td>matriz com os valores numéricos(de cada casa do tabuleiro) inicializados a -1 que seráo agora preenchidos pela função </td></tr>
    <tr><td class="paramname">e</td><td>apontador para o estado do jogo </td></tr>
    <tr><td class="paramname">flag</td><td>indica se estou usando a função para encontrar o caminho mais curto para vitória ou o mais longo para derrota </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a62f43dfd205580f152712e9f18276103"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62f43dfd205580f152712e9f18276103">&#9670;&nbsp;</a></span>transfere_tabuleiro()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void transfere_tabuleiro </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="bot_2dados_8h.html#aba91601f16d4c485b2d9b8c429f27039">CASA</a>&#160;</td>
          <td class="paramname"><em>tabuleiro_1</em>[8][8], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="bot_2dados_8h.html#aba91601f16d4c485b2d9b8c429f27039">CASA</a>&#160;</td>
          <td class="paramname"><em>tabuleiro_2</em>[8][8]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Dado um tabuleiro1 e um tabuleiro2, transfere os dados do tabuleiro 2 para o tabuleiro 1. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tabuleiro_1</td><td>matriz com a informação de um tabuleiro do jogo </td></tr>
    <tr><td class="paramname">tabuleiro_2</td><td>matriz com a informação de outro tabuleiro do jogo </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab3d83ee5bb070d6530437278b415b636"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3d83ee5bb070d6530437278b415b636">&#9670;&nbsp;</a></span>verifica_adjacencia()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int verifica_adjacencia </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCOORDENADA.html">COORDENADA</a>&#160;</td>
          <td class="paramname"><em>coord</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>num_casa</em>[8][8], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>valor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Temos a coordenada "coord". Queremos saber se a CASA no tabuleiro correspondente a essa coordenada "coord" está ao lado de alguma com valor (valor-1.) Para isso corremos todas as posições do tabuleiro até encontrarmos alguma ao lado da coordenada que temos ou chegarmos ao fim do tabuleiro. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">coord</td><td>Coordenada que queremos verificar a adjacência </td></tr>
    <tr><td class="paramname">num_casa</td><td>matriz com os valores numéricos dados a cada possível casa do tabuleiro a partir da estratégia floodfill </td></tr>
    <tr><td class="paramname">valor</td><td>dado a casa atual que queremos verificar a adjacência com casas com (valor -1 ). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a18183af7ccb1fd6405a5f39b1f56ef96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18183af7ccb1fd6405a5f39b1f56ef96">&#9670;&nbsp;</a></span>verifica_casa_vazia()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int verifica_casa_vazia </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structESTADO.html">ESTADO</a> *&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structCOORDENADA.html">COORDENADA</a>&#160;</td>
          <td class="paramname"><em>coordenada</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Dada uma coordenada, verifica se a casa correspondente no tabuleiro está vazia ou não. Devolve 1 caso estiver vazia,0 caso o contrário. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">e</td><td>apontador para o estado do jogo </td></tr>
    <tr><td class="paramname">coordenada</td><td>Coordenada a verificar a casa do tabuleiro </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aaa3fd9c526e661b27383a69e5a5277f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa3fd9c526e661b27383a69e5a5277f0">&#9670;&nbsp;</a></span>verifica_fim()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int verifica_fim </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structESTADO.html">ESTADO</a> *&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>j</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Esta função verifica se o jogo chegou ao fim. Verifica as condições de fim de jogo,isto é, "jogador atual nas extremidades 1 ou 2, ou jogador atual
encurralado". Retorna 0 caso não se verifique nenhum, em contrapartida devolve o número do jogador vencedor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">e</td><td>Apontador para o estado </td></tr>
    <tr><td class="paramname">l</td><td>linha da jogada efetuada </td></tr>
    <tr><td class="paramname">l</td><td>coluna da jogada efetuada </td></tr>
    <tr><td class="paramname">j</td><td>jogador atual </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a47d04407ac67a91a6572ff5011640928"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47d04407ac67a91a6572ff5011640928">&#9670;&nbsp;</a></span>verifica_limite_tabuleiro()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int verifica_limite_tabuleiro </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCOORDENADA.html">COORDENADA</a>&#160;</td>
          <td class="paramname"><em>coordenada</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Dada uma coordenada, verifica se esta é uma coordenada válida de ser jogada , isto é, esta dentro dos limites de memória do tabuleiro. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">coordenada</td><td>Coordenada a verificar se está nos limites do tabuleiro. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6eceb14c20dfd2dc46fe7500803bd534"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6eceb14c20dfd2dc46fe7500803bd534">&#9670;&nbsp;</a></span>verifica_quadrante()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int verifica_quadrante </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structESTADO.html">ESTADO</a> *&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structCOORDENADA.html">COORDENADA</a>&#160;</td>
          <td class="paramname"><em>coord</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Verifica se a coordenada "coord" faz parte de uma das casas que, se for escolhida como casa jogada pelo jogador atual, na próxima jogada ele perderá a partida pois tal casa pertencia as casas que estão ao redor de sua casa da derrota. Por tanto tal função devolve 1 se a coord estiver no quadrante seguro, isto é, sem ser ao redor da casa da derrota, e devolve 0 caso contrário. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">coord</td><td>Coordenada que queremos verificar em qual quadrante está </td></tr>
    <tr><td class="paramname">e</td><td>apontador para o estado do jogo </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad3f8800d9f979e4b250c2603de7dcadd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3f8800d9f979e4b250c2603de7dcadd">&#9670;&nbsp;</a></span>verifica_valida()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int verifica_valida </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structESTADO.html">ESTADO</a> *&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structCOORDENADA.html">COORDENADA</a>&#160;</td>
          <td class="paramname"><em>jog_ant</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structCOORDENADA.html">COORDENADA</a>&#160;</td>
          <td class="paramname"><em>jog_efet</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Esta função verifica se a jogada que se pretende efetuar é válida. Para a jogada ser válida, é necessário que a casa para onde esta se pretende efetuar esteja: 1) Vazia (sendo do tipo VAZIO, UM ou DOIS); 2) A uma distância de 1 na horizontal, vertical, ou diagonal da casa atual. Devolve 1 caso for válida, retorna 0 caso contrário. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">e</td><td>Apontador para o estado </td></tr>
    <tr><td class="paramname">c</td><td>Coordenada da jogada anterior </td></tr>
    <tr><td class="paramname">c</td><td>Coordenada da jogada efetuada </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
